# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    PositiveInt,
    RootModel,
    conint,
    constr,
)


class ChannelNumber(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class AudioTrack(BaseModel):
    """
    Mapping for channels in audio tracks to the Flow channels
    """

    channel_numbers: Optional[List[ChannelNumber]] = Field(
        None,
        description="Array of (zero-based) container channel numbers in Flow order",
        min_length=1,
    )
    channel_range: Optional[constr(pattern=r"^[0-9]+_[0-9]+$")] = Field(
        None, description="Inclusive range of (zero-based) container channel numbers"
    )


class Mp2tsContainer(BaseModel):
    """
    Mapping to MPEG-2 Transport Stream containers, ISO/IEC 13818-1 or ITU-T Recommendation H.222.0
    """

    pid: Optional[int] = Field(
        None, description="The packet ID for the elementary stream packets"
    )


class MxfContainer(BaseModel):
    """
    Mapping to Material Exchange Format containers, SMPTE ST 377-1
    """

    package_uid: Optional[
        constr(
            pattern=r"^urn:smpte:umid:[0-9a-fA-F]{8}(.[0-9a-fA-F]{8}){7}$|^urn:uuid:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
        )
    ] = Field(None, description="The package UID. Either a SMPTE UMID URN or UUID URN")
    track_id: Optional[int] = Field(None, description="The track ID in the package")


class IsobmffContainer(BaseModel):
    """
    Mapping to ISO Base Media File Format (e.g. MP4 and MOV) containers, ISO/IEC 14496-12
    """

    track_id: Optional[int] = Field(None, description="The track ID")


class Containermapping(BaseModel):
    """
    Defines the location of Flow essence data in a container track
    """

    track_index: Optional[conint(ge=0)] = Field(
        None,
        description="A zero-based and sequential track index in the container. This assumes a reliable ordering of tracks",
    )
    format_track_index: Optional[conint(ge=0)] = Field(
        None,
        description="A zero-based and sequential track index in the container for a particular Flow format. A container with a video and 2 audio tracks would have a format_track_index 0 for the video Flow and format_track_index 0 and 1 for the audio Flows. This assumes a reliable ordering of tracks for each Flow format",
    )
    audio_track: Optional[AudioTrack] = Field(
        None, description="Mapping for channels in audio tracks to the Flow channels"
    )
    mp2ts_container: Optional[Mp2tsContainer] = Field(
        None,
        description="Mapping to MPEG-2 Transport Stream containers, ISO/IEC 13818-1 or ITU-T Recommendation H.222.0",
    )
    mxf_container: Optional[MxfContainer] = Field(
        None,
        description="Mapping to Material Exchange Format containers, SMPTE ST 377-1",
    )
    isobmff_container: Optional[IsobmffContainer] = Field(
        None,
        description="Mapping to ISO Base Media File Format (e.g. MP4 and MOV) containers, ISO/IEC 14496-12",
    )


class Contentformat(Enum):
    """
    Identifies the content format for a Flow or Source using a URN string
    """

    urn_x_nmos_format_video = "urn:x-nmos:format:video"
    urn_x_tam_format_image = "urn:x-tam:format:image"
    urn_x_nmos_format_audio = "urn:x-nmos:format:audio"
    urn_x_nmos_format_data = "urn:x-nmos:format:data"
    urn_x_nmos_format_multi = "urn:x-nmos:format:multi"


class Status(Enum):
    """
    Status of the delete request
    """

    created = "created"
    started = "started"
    done = "done"
    error = "error"


class Error(BaseModel):
    """
    Provides more information for an error status.
    """

    type: str = Field(..., description="The error type name.")
    summary: str = Field(
        ..., description="Summary description of the error and causes."
    )
    traceback: Optional[List[str]] = Field(
        None, description="Stack trace leading to error (as a list of strings)"
    )
    time: datetime = Field(
        ..., description="Time at which the error ocurred, to aid in log correlation"
    )


class Eventstreamcommon(BaseModel):
    """
    Describes an event stream mechanism available in this service instance
    """

    name: str = Field(
        ...,
        description="Name of this type of event stream mechanism. Must be unique. Any name defined in this specification is reserved",
    )
    docs: Optional[str] = Field(
        None,
        description="Location (e.g. a URL) at which documentation for this event stream mechanism may be found",
    )
    config: Optional[Dict[str, Any]] = Field(
        None, description="Configuration options required to make use of this mechanism"
    )


class Format(Enum):
    """
    The primary content type URN for the Flow.
    """

    urn_x_nmos_format_audio = "urn:x-nmos:format:audio"


class CodecParameters(BaseModel):
    coded_frame_size: Optional[int] = Field(
        None, description="The fixed number of samples per coded audio frame."
    )
    mp4_oti: Optional[int] = Field(
        None,
        description="The MPEG-4 Object Type Identification. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#mpeg-4_audio",
    )


class UncType(Enum):
    """
    The uncompressed audio multi-channel representation type. If codec is `audio/x-raw-int` or `audio/x-raw-float`, unc_type must be set.
    """

    interleaved = "interleaved"
    planar = "planar"
    pairs = "pairs"


class UncParameters(BaseModel):
    unc_type: UncType = Field(
        ...,
        description="The uncompressed audio multi-channel representation type. If codec is `audio/x-raw-int` or `audio/x-raw-float`, unc_type must be set.",
    )


class EssenceParameters(BaseModel):
    """
    Describes the parameters of the essence inside this audio Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    sample_rate: PositiveInt = Field(
        ..., description="The fixed number of samples per second."
    )
    channels: PositiveInt = Field(..., description="The channel count.")
    bit_depth: Optional[PositiveInt] = Field(
        None,
        description="The number of significant bits used to represent the audio sample. The minumum number of bytes then equals `round_up(bit_depth / 8)`. If codec is `audio/x-raw-int` bit_depth must be set. If codec is `audio/x-raw-float` bit_depth must be set to 32 or 64",
    )
    codec_parameters: Optional[CodecParameters] = Field(
        None, title="Audio Codec Parameters"
    )
    unc_parameters: Optional[UncParameters] = Field(
        None, title="Uncompressed Audio Parameters"
    )


class SegmentDuration(BaseModel):
    """
    The target Flow Segment duration in seconds. The duration for each Segment may vary around this target value. See also the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote for how this property can be used to calculate buffer sizes.
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: Optional[PositiveInt] = Field(1, description="denominator")


class Format1(Enum):
    """
    The primary content type URN for the Flow.
    """

    urn_x_nmos_format_data = "urn:x-nmos:format:data"


class EssenceParameters1(BaseModel):
    """
    Describes the parameters of the essence inside this data Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    data_type: Optional[str] = Field(
        None,
        description="The type of information encoded in the Flow, identified using a URN. e.g. The data_type may be urn:x-tams:data:bounding-box, and the codec `application/json`.",
    )


class Format2(Enum):
    """
    The primary content type URN for the Flow.
    """

    urn_x_tam_format_image = "urn:x-tam:format:image"


class AspectRatio(BaseModel):
    """
    The display aspect ratio. i.e. display_width / display_height
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: PositiveInt = Field(..., description="denominator")


class EssenceParameters2(BaseModel):
    """
    Describes the parameters of the essence inside this image Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    frame_width: PositiveInt = Field(
        ..., description="The width of the picture in pixels."
    )
    frame_height: PositiveInt = Field(
        ..., description="The height of the picture in pixels."
    )
    aspect_ratio: Optional[AspectRatio] = Field(
        None,
        description="The display aspect ratio. i.e. display_width / display_height",
    )


class Format3(Enum):
    """
    The primary content type URN for the Flow.
    """

    urn_x_nmos_format_multi = "urn:x-nmos:format:multi"


class GetUrl(BaseModel):
    url: str = Field(
        ...,
        description="A URL to which a GET request can be made to directly retrieve the contents of the Media Object. Clients should include credentials if the provide URL is on the same origin as the API endpoint",
    )
    label: Optional[str] = Field(
        None,
        description="Label identifying this URL. Service implementations should reject any requests using labels that are already associated with Storage Backends. If the 'label' is not set then this URL can't be filtered for using the 'accept_get_urls' API query parameter.",
    )


class Format4(Enum):
    """
    The primary content type URN for the Flow.
    """

    urn_x_nmos_format_video = "urn:x-nmos:format:video"


class FrameRate(BaseModel):
    """
    The fixed number of frames per second. If this parameter is unset, the frame_rate is either unknown or variable.
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: Optional[PositiveInt] = Field(1, description="denominator")


class InterlaceMode(Enum):
    """
    Interlaced video mode for frames in this Flow
    """

    progressive = "progressive"
    interlaced_tff = "interlaced_tff"
    interlaced_bff = "interlaced_bff"
    interlaced_psf = "interlaced_psf"


class Colorspace(Enum):
    """
    Colorspace used for the video
    """

    BT601 = "BT601"
    BT709 = "BT709"
    BT2020 = "BT2020"
    BT2100 = "BT2100"


class TransferCharacteristic(Enum):
    """
    Transfer characteristic
    """

    SDR = "SDR"
    HLG = "HLG"
    PQ = "PQ"


class PixelAspectRatio(BaseModel):
    """
    The pixel aspect ratio. This is usually 1:1 (i.e. square pixels) for modern video. Some, usually older, video formats use non-square pixels e.g. some Standard Definition video. This is where that may be indicated.
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: PositiveInt = Field(..., description="denominator")


class ComponentType(Enum):
    """
    Picture component representation.
    """

    YCbCr = "YCbCr"
    RGB = "RGB"


class UncType1(Enum):
    """
    Uncompressed picture packing type. If codec is `video/raw`, unc_type must be set.
    """

    planar = "planar"
    YUYV = "YUYV"
    UYVY = "UYVY"
    AYUV = "AYUV"
    v210 = "v210"
    v216 = "v216"
    RGB = "RGB"
    RGBx = "RGBx"
    xRGB = "xRGB"
    BGRx = "BGRx"
    xBGR = "xBGR"
    RGBA = "RGBA"
    ARGB = "ARGB"
    BGRA = "BGRA"
    ABGR = "ABGR"
    alpha = "alpha"


class UncParameters1(BaseModel):
    unc_type: UncType1 = Field(
        ...,
        description="Uncompressed picture packing type. If codec is `video/raw`, unc_type must be set.",
    )


class AvcParameters(BaseModel):
    profile: int = Field(
        ...,
        description="AVC / H.264 profile byte. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#using_the_codecs_parameter",
    )
    level: int = Field(
        ...,
        description="AVC / H.264 level byte. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#using_the_codecs_parameter",
    )
    flags: int = Field(
        ...,
        description="AVC / H.264 flags byte. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#using_the_codecs_parameter",
    )


class EssenceParameters3(BaseModel):
    """
    Describes the parameters of the essence inside this video Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    frame_rate: Optional[FrameRate] = Field(
        None,
        description="The fixed number of frames per second. If this parameter is unset, the frame_rate is either unknown or variable.",
    )
    frame_width: PositiveInt = Field(
        ..., description="The width of the picture in pixels."
    )
    frame_height: PositiveInt = Field(
        ..., description="The height of the picture in pixels."
    )
    bit_depth: Optional[PositiveInt] = Field(
        None,
        description="The number of significant bits used to represent the video component sample. If codec is `video/raw`, bit_depth must be set.",
    )
    interlace_mode: Optional[InterlaceMode] = Field(
        None, description="Interlaced video mode for frames in this Flow"
    )
    colorspace: Optional[Colorspace] = Field(
        None, description="Colorspace used for the video"
    )
    transfer_characteristic: Optional[TransferCharacteristic] = Field(
        None, description="Transfer characteristic"
    )
    aspect_ratio: Optional[AspectRatio] = Field(
        None,
        description="The display aspect ratio. i.e. display_width / display_height",
    )
    pixel_aspect_ratio: Optional[PixelAspectRatio] = Field(
        None,
        description="The pixel aspect ratio. This is usually 1:1 (i.e. square pixels) for modern video. Some, usually older, video formats use non-square pixels e.g. some Standard Definition video. This is where that may be indicated.",
    )
    component_type: Optional[ComponentType] = Field(
        None, description="Picture component representation."
    )
    horiz_chroma_subs: Optional[PositiveInt] = Field(
        None,
        description="Horizontal chroma component sub-sampling. When unc_type is set to a YUV type, horiz_chroma_subs must be set.",
    )
    vert_chroma_subs: Optional[PositiveInt] = Field(
        None,
        description="Vertical chroma component sub-sampling. When unc_type is set to a YUV type, vert_chroma_subs must be set.",
    )
    unc_parameters: Optional[UncParameters1] = Field(
        None, title="Uncompressed Video Parameters"
    )
    avc_parameters: Optional[AvcParameters] = Field(None, title="AVC Codec Parameters")


class Httprequest(BaseModel):
    """
    Gives information on a particular http request a client should perform
    """

    model_config = ConfigDict(
        extra="allow",
    )
    url: str = Field(..., description="The URL to make the request to")
    body: Optional[str] = Field(
        None,
        description="The text of the body which needs to be included in the request",
    )
    content_type: Optional[str] = Field(
        None, alias="content-type", description="The content type which must be used"
    )
    headers: Optional[Dict[str, str]] = Field(
        None, description="Additional headers that should be included"
    )


class Mimetype(
    RootModel[
        constr(
            pattern=r"^(application|audio|font|example|image|message|model|multipart|text|video|x-(?:[0-9A-Za-z!#$%&\'*+.^_`|~-]+))/([0-9A-Za-z!#$%&\'*+.^_`|~-]+)$"
        )
    ]
):
    root: constr(
        pattern=r"^(application|audio|font|example|image|message|model|multipart|text|video|x-(?:[0-9A-Za-z!#$%&\'*+.^_`|~-]+))/([0-9A-Za-z!#$%&\'*+.^_`|~-]+)$"
    ) = Field(
        ...,
        description="A Mime Type without parameters as defined in [RFC2045](https://www.rfc-editor.org/rfc/rfc2045#section-5.1) and [RFC7231](https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1)",
        title="MIME Type",
    )


class Service(BaseModel):
    """
    Provides information about the service instance
    """

    name: Optional[str] = Field(
        None,
        description="The service instance name. This should be a very short, human-readable name that may be displayed in listings of Service instances.",
    )
    description: Optional[str] = Field(
        None,
        description="The service instance description. This should be a human-readable description that may be showed in detailed views of Service instances. The description should be longer and more detailed than `name`.",
    )
    type: str = Field(
        ...,
        description="The type identifier for the service instance. The value must start with 'urn:x-tams:service'",
    )
    api_version: constr(pattern=r"^(0|[1-9]\d*)\.(0|[1-9]\d*)$") = Field(
        ...,
        description="The version of the TAMS API specification this service instance implements",
    )
    service_version: Optional[str] = Field(
        None,
        description="The version of software providing this service. Note: Different implementations and software houses may use different conventions for their version identification. As such, this field is intentionally permissive and intended to be informative only. Client implementations should avoid using this field to determine compatibility.",
    )
    event_stream_mechanisms: Optional[List[Eventstreamcommon]] = Field(
        None,
        description="List the types of event stream that this service implementation supports",
    )


class Servicepost(BaseModel):
    """
    Post update to the service info
    """

    name: Optional[str] = Field(None, description="The service instance name")
    description: Optional[str] = Field(
        None, description="The service instance description"
    )


class StoreType(Enum):
    """
    The generic Storage Backend type. Used to identify the required workflow for reading and writing media. Any `store_product` should be compatible, as much is required for basic interoperability between TAMS implementations, with their associated generic `store_type`.
    """

    http_object_store = "http_object_store"


class Storagebackend(BaseModel):
    """
    Provides technical, and logic metadata about a storage backend
    """

    store_type: Optional[StoreType] = Field(
        None,
        description="The generic Storage Backend type. Used to identify the required workflow for reading and writing media. Any `store_product` should be compatible, as much is required for basic interoperability between TAMS implementations, with their associated generic `store_type`.",
    )
    provider: Optional[str] = Field(
        None, description="The cloud (or other) provider of the Storage Backend"
    )
    region: Optional[str] = Field(
        None, description="The region in the cloud this Storage Backend resides"
    )
    availability_zone: Optional[str] = Field(
        None,
        description="The availability zone in the cloud region this Storage Backend resides. Note that many cloud providers randomize availability zone identifiers such that they are consistent within a cloud account, but not necessarily between accounts. Caution should be exercised when using this parameter.",
    )
    store_product: Optional[str] = Field(None, description="The storage product name.")


class Tags(RootModel[Optional[Dict[str, str]]]):
    """
    Key value is a freeform string.
    """

    root: Optional[Dict[str, str]] = None


class Timerange(
    RootModel[
        constr(
            pattern=r"^(\[|\()?(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?(_(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?)?(\]|\))?$"
        )
    ]
):
    root: constr(
        pattern=r"^(\[|\()?(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?(_(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?)?(\]|\))?$"
    ) = Field(
        ...,
        description="A timerange of timestamps. It is represented using one or two timestamps with inclusivity and exclusivity markers.\n\nE.g.\n* `[0:0_10:0)` represents 10 seconds of media starting at timestamp `0:0` and ending before `10:0`.\n* `(5:0_` represents a timerange starting after `5:0` and to eternity.\n* `[1694429247:0_1694429248:0)` is a 1 second TAI timerange starting at 2023-09-11T10:46:50.0Z UTC.\n* `[1694429247:0]` is an instantaneous TAI timerange at 2023-09-11T10:46:50.0Z UTC.\n  This is equivalent to `[1694429247:0_1694429247:0]`.\n  The short syntax is preferred due to ease of identification as instantaneous.\n  Instantaneous TimeRanges cannot use exclusive markers (i.e. `(` or `)`).\n* A `[` or `]` indicates that bound is inclusive, and a `(` or `)` indicates that bound is exclusive.\n\nDetails of the format can be found in the [Timestamps in TAMS](https://github.com/bbc/tams/blob/main/docs/appnotes/0008-timestamps-in-TAMS.md) application note.\n",
        title="TimeRange",
    )


class Timestamp(RootModel[constr(pattern=r"^-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8})$")]):
    root: constr(pattern=r"^-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8})$") = Field(
        ...,
        description='A signed nanosecond resolution timestamp represented as "{sign?}{seconds}:{nanoseconds}". The intended\ninterpretation of the value is assumed to be defined elsewhere.\n\nE.g.\n* "1:40000000" is the timestamp of the 27th video frame for 25 Hz video with origin at "0:0".\n* "1694429247:40000000" is the TAI timestamp for a video frame at 2023-09-11T10:46:50.04Z UTC.\n\nDetails of the format can be found in the [Timestamps in TAMS](https://github.com/bbc/tams/blob/main/docs/appnotes/0008-timestamps-in-TAMS.md) application note.\n',
        title="Timestamp",
    )


class Urllabellist(RootModel[constr(pattern=r"^([^,]+(,[^,]+)*)?$")]):
    root: constr(pattern=r"^([^,]+(,[^,]+)*)?$") = Field(
        ...,
        description="A list of Media Object GET URL Labels, formatted for use in query string parameters",
        title="Query String GET URL Label list",
    )


class Uuid(
    RootModel[
        constr(
            pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
        )
    ]
):
    root: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(
        ...,
        description="A Universally Unique Identifier (UUID) as defined in [RFC9562](https://www.rfc-editor.org/rfc/rfc9562)",
        title="UUID",
    )


class Uuidlist(
    RootModel[
        constr(
            pattern=r"^([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})(,[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})*$"
        )
    ]
):
    root: constr(
        pattern=r"^([0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})(,[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})*$"
    ) = Field(
        ...,
        description="A list of Universally Unique Identifiers (UUIDs) as defined in [RFC9562](https://www.rfc-editor.org/rfc/rfc9562), formatted for use in query string parameters",
        title="Query String UUID list",
    )


class Event(Enum):
    flows_created = "flows/created"
    flows_updated = "flows/updated"
    flows_deleted = "flows/deleted"
    flows_segments_added = "flows/segments_added"
    flows_segments_deleted = "flows/segments_deleted"
    sources_created = "sources/created"
    sources_updated = "sources/updated"
    sources_deleted = "sources/deleted"


class Webhook(BaseModel):
    """
    Register to receive updates via webhook
    """

    url: str = Field(
        ...,
        description="The URL to which the service instance should make HTTP POST requests with event data",
    )
    api_key_name: Optional[str] = Field(
        None, description="The HTTP header name that is added to the event POST"
    )
    events: List[Event] = Field(..., description="List of event types to receive")
    flow_ids: Optional[List[Uuid]] = Field(
        None,
        description="Limit Flow and Flow Segment events to Flows in the given list of Flow IDs",
    )
    source_ids: Optional[List[Uuid]] = Field(
        None,
        description="Limit Flow, Flow Segment and Source events to Sources in the given list of Source IDs",
    )
    flow_collected_by_ids: Optional[List[Uuid]] = Field(
        None,
        description="Limit Flow and Flow Segment events to those with Flow that is collected by a Flow Collection in the given list of Flow Collection IDs",
    )
    source_collected_by_ids: Optional[List[Uuid]] = Field(
        None,
        description="Limit Flow, Flow Segment and Source events to those with Source that is collected by a Source Collection in the given list of Source Collection IDs",
    )
    accept_get_urls: Optional[List[str]] = Field(
        None,
        description="List of labels of URLs to include in the `get_urls` property in `flows/segments_added` events. Where multiple `get_urls` filter query parameters are provided, the included `get_urls` will match all filters. This option is the same as the `accept_get_urls` query parameter for the [/flows/{flowId}/segments](#/operations/GET_flows-flowId-segments) API endpoint, except that the labels are represented using a JSON array rather than a (comma separated list) string.",
    )
    accept_storage_ids: Optional[List[Uuid]] = Field(
        None,
        description="List of labels of `storage_id`s to include in the `get_urls` property in `flows/segments_added` events. Where multiple `get_urls` filter query parameters are provided, the included `get_urls` will match all filters. This option is the same as the `accept_storage_ids` query parameter for the [/flows/{flowId}/segments](#/operations/GET_flows-flowId-segments) API endpoint, except that the IDs are represented using a JSON array rather than a (comma separated list) string.",
    )
    presigned: Optional[bool] = Field(
        None,
        description="Whether to include presigned/non-presigned URLs in the `get_urls` property in `flows/segments_added` events. Where multiple `get_urls` filter query parameters are provided, the included `get_urls` will match all filters. This option is the same as the `presigned` query parameter for the [/flows/{flowId}/segments](#/operations/GET_flows-flowId-segments) API endpoint.",
    )
    verbose_storage: Optional[bool] = Field(
        None,
        description="Whether to include storage metadata in the `get_urls` property in `flows/segments_added` events. This option is the same as the `verbose_storage` query parameter for the [/flows/{flowId}/segments](#/operations/GET_flows-flowId-segments) API endpoint.",
    )


class Status1(Enum):
    """
    Status of the Webhook. `created` indicates the webhook has been successfully registered but is yet to begin sending events or, depending on the service implementation, the worker responsible for sending the events has yet to start. `started` indicates the webhook is active and sending events. `disabled` indicates the webhook has been disabled by a client and is not currently sending events. `error` indicates an error condition has been encountered and the webhook has been disabled by the service instance. More information about the error condition will be indicated by the service instance in the `error` parameter. Service implementations SHOULD implement appropriate retries and only enter the `error` state when absolutely necesary. A webhook in the `error` or `disabled` state may be re-enabled by a client by setting the status to `created`. A webhook in the `created` or `started` state may be disabled by a client by setting the status to `disabled`. Attempting to transition an `error` status to `disabled` SHOULD be rejected.
    """

    created = "created"
    started = "started"
    disabled = "disabled"
    error = "error"


class Status2(Enum):
    """
    Status of the Webhook. `created` will register the webhook in the created state and the service instance will attempt to start sending events. `disabled` will register the webhook in a disabled state and will not send events. Assumed to be `created` if not set.
    """

    created = "created"
    disabled = "disabled"


class Webhookpost(Webhook):
    """
    Register to receive updates via webhook
    """

    api_key_value: Optional[str] = Field(
        None, description="The value that the HTTP header 'api_key_name' will be set to"
    )
    status: Optional[Status2] = Field(
        None,
        description="Status of the Webhook. `created` will register the webhook in the created state and the service instance will attempt to start sending events. `disabled` will register the webhook in a disabled state and will not send events. Assumed to be `created` if not set.",
    )


class Status3(Enum):
    """
    Status of the Webhook. `created` indicates the webhook has been successfully registered but is yet to begin sending events or, depending on the service implementation, the worker responsible for sending the events has yet to start. `started` indicates the webhook is active and sending events. `disabled` indicates the webhook has been disabled by a client and is not currently sending events. `error` indicates an error condition has been encountered and the webhook has been disabled by the service instance. More information about the error condition will be indicated by the service instance in the `error` parameter. Service implementations SHOULD implement appropriate retries and only enter the `error` state when absolutely necesary. A webhook in the `error` or `disabled` state may be re-enabled by a client by setting the status to `created`. A webhook in the `created` or `started` state may be disabled by a client by setting the status to `disabled`. Attempting to transition an `error` status to `disabled` SHOULD be rejected.
    """

    created = "created"
    disabled = "disabled"


class Webhookwithid(Webhook):
    """
    Details of an existing registered webhook
    """

    id: Uuid = Field(..., description="Webhook identifier")


class Collectionitem(BaseModel):
    """
    Describes how an entity (Source or Flow) is collected into another entity of the same type
    """

    id: Uuid = Field(
        ...,
        description="Source or Flow Identifier of the member of this collection. Sources MUST only collect Sources, and Flows MUST only collect Flows. Must already be registered in this service instance",
    )
    role: str = Field(
        ...,
        description="A human-readable role of the element in this collection (e.g. 'R' to denote a right audio channel in a collection of mono audio Sources)",
    )


class Deletionrequest(BaseModel):
    """
    Describes an ongoing deletion request
    """

    id: Uuid = Field(..., description="Deletion Request ID")
    flow_id: Uuid = Field(
        ..., description="ID of the Flow to which the deletion request relates"
    )
    timerange_to_delete: Timerange = Field(
        ...,
        description="The timerange of Flow Segments to be deleted in this request, as described by the [TimeRange](#/schemas/timerange) type",
    )
    timerange_remaining: Optional[Timerange] = Field(
        None,
        description="The timerange of Flow Segments not yet deleted by this request, as described by the [TimeRange](#/schemas/timerange) type",
    )
    delete_flow: bool = Field(
        ...,
        description="Whether the Flow should be deleted once the timerange has been",
    )
    created: Optional[datetime] = Field(
        None, description="Date/Time when this deletion request was created"
    )
    created_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that created the deletion request. Service implementations SHOULD set suitable default values for `created_by` based on the principal accessing the system.",
    )
    updated: Optional[datetime] = Field(
        None, description="Date/Time when this deletion request was updated"
    )
    expiry: Optional[datetime] = Field(
        None, description="Date/Time when this deletion request will be deleted"
    )
    status: Status = Field(..., description="Status of the delete request")
    error: Optional[Error] = Field(
        None,
        description="Provides more information for the error status, as described by the [Error](#/schemas/error) type",
    )


class FlowcollectionItem(Collectionitem):
    container_mapping: Optional[Containermapping] = Field(
        None,
        description="Describes the mapping of the Flow essence from this Flow collection's container",
    )


class Flowcollection(RootModel[List[FlowcollectionItem]]):
    """
    Describes how Flows are collected into another Flow
    """

    root: List[FlowcollectionItem] = Field(
        ...,
        description="Describes how Flows are collected into another Flow",
        title="Flow Collection",
    )


class Flowcore(BaseModel):
    """
    Describes a Flow (common properties to all Flows, imported by type-specific specifications)
    """

    id: Uuid = Field(..., description="Flow identifier")
    source_id: Uuid = Field(..., description="Source identifier")
    label: Optional[str] = Field(
        None,
        description="Freeform string label for the Flow. This should be a very short, human-readable label that may be displayed in listings of Flows.",
    )
    description: Optional[str] = Field(
        None,
        description="Freeform text describing the Flow. This should be a human-readable description that may be showed in detailed views of Flows. The description should be longer and more detailed than `label`.",
    )
    created_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that created the Flow. Service implementations SHOULD set suitable default values for `created_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    updated_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that updated the Flow metadata most recently. Service implementations SHOULD set suitable default values for `updated_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    tags: Optional[Tags] = Field(
        None,
        description="Key value is a freeform string. WARNING: When updating a Flow with `tags` set, `tags` will be replaced with the provided dictionary. `tags` WILL NOT be merged with the provided values. When `tags` is not set in the request, `tags` will be unset (i.e. set to `{}`). To update individual tags, clients should use the [Create or Update Flow Tag](#/operations/PUT_flows-flowId-tags-name) endpoint.",
    )
    metadata_version: Optional[str] = Field(
        None,
        description="A change to the Flow metadata, not including metadata_version, metadata_updated, segments_updated, or Segments, results in a new version. If the metadata_version for Flow instances is identical then the metadata is identical. Service implementations SHOULD set suitable default values for `metadata_version` whenever Flow metadata is changed and `metadata_version` is either not set by the client, or set to it's existing value. Service implementations MAY permit clients to edit the value, subject to suitable permissions-based limitations. Where media is transfered between TAMS service instances without changing the Flow metadata, clients SHOULD maintain the `metadata_version`. To support this, service implementations SHOULD always accept the setting of `metadata_version` by the client on initial Flow creation. Service implementations SHOULD update this field where metadata is updated via child endpoints. Note that this specification places no requirements on incremental versioning. Service implementations may, for example, choose to use hashes or date-time version identifiers.",
    )
    generation: Optional[conint(ge=0)] = Field(
        None,
        description='An indication of how many lossy encodings the Flow content has been through. This parameter provides a hint to clients as to which is the "highest qualty" Flow available to them. A Flow with a higher generation may contain less of the original information than a Flow with a lower generation. Where a Flow is captured straight from the orginating device (e.g. camera/microphone) in its highest quality, and there is no possibility of the content becoming available in a higher quality (e.g. via capture from ST2110 or SDI), it SHOULD have a `generation` of `0`. Where the originating device outputs multiple qualities of the Source, `generation` should represent the encoding processes each has been through as accurately as possible.',
    )
    created: Optional[datetime] = Field(
        None,
        description="The date-time the Flow was created in a given context, e.g. in the service instance. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    metadata_updated: Optional[datetime] = Field(
        None,
        description="The date-time the Flow metadata was updated in a given context, e.g. in the service instance. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    segments_updated: Optional[datetime] = Field(
        None,
        description="The date-time the Flow Segments were updated in a given context, e.g. in the service instance. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    read_only: Optional[bool] = Field(
        None,
        description="If set to 'true', service implementations SHOULD reject client requests to update Flow metadata (other than the read_only property), and Flow Segments. Service implementations should also reject requests to the [`/flows/{flowId}/storage`](#/operations/POST_flows-flowId-storage) endpoint for the Flow, and requests to delete the Flow.",
    )
    codec: Optional[Mimetype] = Field(
        None,
        description="A MIME type identification of the (lossy or lossless) coding used for the Flow content. Note that the `type` component of the container MIME type (i.e. the component before the `/`) may be different to the `type` component of the codec MIME type. e.g. An audio Flow may have `audio/aac` coded content may be wrapped in a `video/mp2t` container. Mime types from the [IANA registry](https://www.iana.org/assignments/media-types/media-types.xhtml) should be preferred. Where multiple MIME types are possible, the most common should be preferred. Where this is insufficient, the maintainers of the TAMS repository may create an application note advising which MIME type to use.",
    )
    container: Optional[Mimetype] = Field(
        None,
        description="The container MIME type for Flow Segments. Note that the `type` component of the container MIME type (i.e. the component before the `/`) may be different to the `type` component of the codec MIME type. e.g. An audio Flow may have `audio/aac` coded content may be wrapped in a `video/mp2t` container. Where multiple types exist for a subtype (e.g. `video/mp4`, `audio/mp4`, `application/mp4`), the closest MIME type to the Flow `format` should be used (e.g. `audio/mp4` for a Flow `format` of `urn:x-nmos:format:audio`). Mime types from the [IANA registry](https://www.iana.org/assignments/media-types/media-types.xhtml) should be preferred. Where multiple MIME types are possible, the most common should be preferred. Where this is insufficient, the maintainers of the TAMS repository may create an application note advising which MIME type to use.",
    )
    avg_bit_rate: Optional[conint(ge=0)] = Field(
        None,
        description="The average bit rate of the Flow Segments in 1000 bits/second. A precise definition can be found in the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote.",
    )
    max_bit_rate: Optional[conint(ge=0)] = Field(
        None,
        description="The maximum bit rate of the Flow Segments in 1000 bits/second. A precise definition can be found in the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote.",
    )
    segment_duration: Optional[SegmentDuration] = Field(
        None,
        description="The target Flow Segment duration in seconds. The duration for each Segment may vary around this target value. See also the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote for how this property can be used to calculate buffer sizes.",
    )
    timerange: Optional[Timerange] = Field(
        None,
        description="The timerange of samples available in the Flow, as described by the [TimeRange](#/schemas/timerange) type. Service implementations MUST ignore this if given in a PUT request, and instead manage it internally.",
    )
    flow_collection: Optional[Flowcollection] = Field(
        None, description="List of Flows that are collected together by this Flow."
    )
    collected_by: Optional[List[Uuid]] = Field(
        None,
        description="Flows that reference this Flow to include it in a collection. This attribute is intended to be read-only. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    container_mapping: Optional[Containermapping] = Field(
        None,
        description="Describes the mapping of the Flow essence from the this Flow's container",
    )


class Flowdata(Flowcore):
    """
    Describes a data Flow
    """

    format: Format1 = Field(
        ..., description="The primary content type URN for the Flow."
    )
    essence_parameters: EssenceParameters1 = Field(
        ...,
        description="Describes the parameters of the essence inside this data Flow",
        title="Data Flow Essence Parameters",
    )


class Flowimage(Flowcore):
    """
    Describes a still image Flow, for use by thumbnail tracks etc
    """

    format: Format2 = Field(
        ..., description="The primary content type URN for the Flow."
    )
    essence_parameters: EssenceParameters2 = Field(
        ...,
        description="Describes the parameters of the essence inside this image Flow",
        title="Image Flow Essence Parameters",
    )


class Flowmulti(Flowcore):
    """
    Describes a multi-essence Flow
    """

    format: Format3 = Field(
        ..., description="The primary content type URN for the Flow."
    )


class FailedSegment(BaseModel):
    """
    Failed Segment details
    """

    object_id: str = Field(
        ...,
        description="The Object ID of the Segment which has failed to register with the service instance",
    )
    timerange: Optional[Timerange] = Field(
        None,
        description="The timerange of Segment that has failed, as described by the [TimeRange](#/schemas/timerange) type",
    )
    error: Optional[Error] = Field(
        None,
        description="Provides more information for the error status, as described by the [Error](#/schemas/error) type",
    )


class Flowsegmentbulkfailure(BaseModel):
    """
    List of Segments that have failed to register
    """

    failed_segments: List[FailedSegment] = Field(
        ...,
        description="The list of Segments which have failed to register with the service instance",
    )


class Flowsegmentpost(BaseModel):
    """
    Provides the location and metadata of the media files corresponding to timerange Segments of a Flow.
    """

    object_id: str = Field(
        ..., description="The Object identifier for the Media Object."
    )
    ts_offset: Optional[Timestamp] = Field(
        None,
        description="The timestamp offset between the sample timestamps stored in, or inferred from, the media file and the corresponding timestamp in the Segment, ie. ts_offset = segment ts - media object ts. Assumed to be 0:0 if not set. Format as described by the [Timestamp](#/schemas/timestamp) type",
    )
    timerange: Timerange = Field(
        ...,
        description="The timerange for the samples contained in the Segment. The timerange start is always inclusive. If samples have a duration then the timerange end is exclusive and covers at least the duration of the last sample. The exclusive timerange end will typically be set to the timestamp of the next sample. If the samples don't have a duration then the timerange end is inclusive. Format is described by the [TimeRange](#/schemas/timerange) type. Note that where temporal re-ordering is used, the timerange and samples refers to the presentation timeline.",
    )
    last_duration: Optional[Timestamp] = Field(
        None,
        description="The difference between the exclusive end of the `timerange` and the last sample timestamp. Format as described by the [Timestamp](#/schemas/timestamp) type, but cannot be negative",
    )
    sample_offset: Optional[int] = Field(
        None,
        description="The start of the Segment represented as a count of samples from the start of the Object. Note that a sample is a video frame or audio sample. A (coded) audio frame has multiple audio samples. Assumed to be 0 if not set. Must be set if the Flow Segment doesn't start at the beginning of the Media Object.",
    )
    sample_count: Optional[int] = Field(
        None,
        description="The count of samples in the Segment (which may be fewer than in the Object). The count could be less than expected given the Segment duration and rate if there are gaps. If not set, every sample from sample_offset onwards is used. Must be set if the Flow Segment doesn't use the entire Media Object. Note that a sample is a video frame or audio sample. A (coded) audio frame has multiple audio samples",
    )
    get_urls: Optional[List[GetUrl]] = Field(
        None,
        description="A list of URLs to which a GET request can be made to directly retrieve the contents of the Media Object. This is required by the `http_object_store` Storage Backend type, which is the only one currently described. Clients may choose any URL in the list and treat them as identical, however service instances may sort the list such that the preferred URL is first. `get_urls` should only be used to add uncontrolled URLs. URLs for the provided object_id controlled by the service instance will be populated automatically by the service instance.",
    )
    key_frame_count: Optional[int] = Field(
        None,
        description="The number of key frames in the Media Object. This should be set greater than zero when the Media Object contains key frames that serve as a stream access point",
    )


class MediaObject(BaseModel):
    """
    Information for a Media Object
    """

    object_id: str = Field(
        ..., description="The object store identifier for the Media Object."
    )
    put_url: Httprequest


class Flowstorage(BaseModel):
    """
    Gives information on storage for Media Objects. This schema is for the `http_object_store` Storage Backend type which provides URLs for storing Media Objects in object store buckets, and is the only Storage Backend type currently implemented.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    media_objects: Optional[List[MediaObject]] = Field(
        None,
        description="List of information for identifying and uploading Media Objects",
    )


class Flowstoragepost(BaseModel):
    """
    Post data for the Flow storage endpoint
    """

    limit: Optional[int] = Field(
        None,
        description="Limit the number of Media Objects in each response page. Service implementations may specify their own default and maximum for the limit",
    )
    object_ids: Optional[List[str]] = Field(
        None,
        description="Array of object_ids to use. The supplied object_ids must be new and not already in use in this TAMS service instance. A 400 response will be returned if any supplied object_id already exists.",
    )
    storage_id: Optional[Uuid] = Field(
        None,
        description="The Storage Backend to allocate storage in. A Storage Backend identifier as advertised at the [/service/storage-backends](#/operations/GET_storage-backends) endpoint. If not set the default, as advertised at the [/service/storage-backends](#/operations/GET_storage-backends) endpoint, will be used if available. An invalid Storage Backend identifier will result in a 400 error.",
    )


class Flowvideo(Flowcore):
    """
    Describes a video Flow
    """

    format: Format4 = Field(
        ..., description="The primary content type URN for the Flow."
    )
    essence_parameters: EssenceParameters3 = Field(
        ...,
        description="Describes the parameters of the essence inside this video Flow",
        title="Video Flow Essence Parameters",
    )


class GetUrl1(Storagebackend):
    storage_id: Optional[Uuid] = Field(None, description="Storage Backend identifier")
    url: str = Field(
        ...,
        description="A URL to which a GET request can be made to directly retrieve the contents of the media object. Clients should include credentials if the provide URL is on the same origin as the API endpoint",
    )
    presigned: Optional[bool] = Field(
        None,
        description="If `true`, this URL is pre-signed. If this parameter is unset, the URL is NOT pre-signed.",
    )
    label: Optional[str] = Field(
        None,
        description="Label identifying this URL. If the URL is controlled by the service instance, this is the Storage Backend's label. If the URL is uncontrolled, this is the label provided when a client registered the URL. If the 'label' is not set then this URL can't be filtered for using the 'accept_get_urls' API query parameter.",
    )
    controlled: Optional[bool] = Field(
        None,
        description="If `true`, this URL is on a Storage Backend controlled by this service instance. If `false`, this URL is uncontrolled and does not have it's lifecycle managed by this instance. If this parameter is unset, assume `true`.",
    )


class Objectcore(BaseModel):
    """
    Provides the location and metadata of the media files corresponding to a Media Object.
    """

    get_urls: Optional[List[GetUrl1]] = Field(
        None,
        description="A list of URLs to which a GET request can be made to directly retrieve the contents of the Media Object. This is required by the `http_object_store` Storage Backend type, which is the only one currently described. Clients may choose any URL in the list and treat the content returned as identical, however servers may sort the list such that the preferred URL is first. Storage Backend metadata for controlled URLs should be populated by the TAMS instance based on the Storage Backend the Meda Object instance resides in.",
    )
    key_frame_count: Optional[int] = Field(
        None,
        description="The number of key frames in the Media Object. This should be set greater than zero when the Media Object contains key frames that serve as a stream access point",
    )


class Source(BaseModel):
    """
    Describes a Source: an abstract representation of a piece of media as defined in <https://specs.amwa.tv/ms-04/releases/v1.0.0/docs/2.2._Explanation_-_Source.html>

    Sources may be elemental (and represented directly by a Flow), or may represent a collection of other Sources, e.g. a Source collecting video and audio together.
    """

    id: Uuid = Field(..., description="Source identifier")
    format: Contentformat = Field(
        ..., description="The primary content type URN for the Source."
    )
    label: Optional[str] = Field(
        None,
        description="Freeform string label for the Source. This should be a very short, human-readable label that may be displayed in listings of Sources.",
    )
    description: Optional[str] = Field(
        None,
        description="Freeform text describing the Source. This should be a human-readable description that may be showed in detailed views of Sources. The description should be longer and more detailed than `label`.",
    )
    created_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that created the Source. Service implementations SHOULD set suitable default values for `created_by` based on the principal accessing the systems.",
    )
    updated_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that updated the Source metadata most recently. Service implementations SHOULD set suitable default values for `updated_by` based on the principal accessing the system.",
    )
    created: Optional[datetime] = Field(
        None,
        description="The date-time the Source was created in a given context, e.g. in the service instance. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    updated: Optional[datetime] = Field(
        None,
        description="The date-time the Source metadata was last updated in a given context, e.g. in the service instance. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    tags: Optional[Tags] = None
    source_collection: Optional[List[Collectionitem]] = Field(
        None,
        description="List of Sources that are collected together by this Source. This attribute is intended to be read-only. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally. Source collections can be inferred from Flow collection definitions.",
    )
    collected_by: Optional[List[Uuid]] = Field(
        None,
        description="Sources that reference this Source to include it in a collection. This attribute is intended to be read-only. Service implementations SHOULD ignore this if given in a PUT request, and instead manage it internally. Source collections can be inferred from Flow collection definitions.",
    )


class StoragebackendslistItem(Storagebackend):
    id: Uuid = Field(..., description="Storage backend identifier")
    label: Optional[str] = Field(
        None, description="Freeform string label for a storage backend."
    )
    default_storage: Optional[bool] = Field(
        None,
        description="If set to `true`, this is the default storage backend. The default storage backend will be used if the client does not specify a storage backend id when requesting the allocation of storage. If this parameter is not set, assume `false`. Service instances may either set one storage backend as default, or none - indicating that clients must always specify a storage backend.",
    )


class Storagebackendslist(RootModel[List[StoragebackendslistItem]]):
    """
    Information about the storage backends available on this service instance.
    """

    root: List[StoragebackendslistItem] = Field(
        ...,
        description="Information about the storage backends available on this service instance.",
        title="Storage Backends List",
    )


class Webhookget(Webhookwithid):
    """
    Describes a Webhook
    """

    error: Optional[Error] = Field(
        None,
        description="Provides more information for the error status, as described by the [Error](../schemas/error#top) type",
    )
    status: Status1 = Field(
        ...,
        description="Status of the Webhook. `created` indicates the webhook has been successfully registered but is yet to begin sending events or, depending on the service implementation, the worker responsible for sending the events has yet to start. `started` indicates the webhook is active and sending events. `disabled` indicates the webhook has been disabled by a client and is not currently sending events. `error` indicates an error condition has been encountered and the webhook has been disabled by the service instance. More information about the error condition will be indicated by the service instance in the `error` parameter. Service implementations SHOULD implement appropriate retries and only enter the `error` state when absolutely necesary. A webhook in the `error` or `disabled` state may be re-enabled by a client by setting the status to `created`. A webhook in the `created` or `started` state may be disabled by a client by setting the status to `disabled`. Attempting to transition an `error` status to `disabled` SHOULD be rejected.",
    )


class Webhookput(Webhookwithid):
    """
    Modify existing webhook
    """

    api_key_value: Optional[str] = Field(
        None, description="The value that the HTTP header 'api_key_name' will be set to"
    )
    status: Status3 = Field(
        ...,
        description="Status of the Webhook. `created` indicates the webhook has been successfully registered but is yet to begin sending events or, depending on the service implementation, the worker responsible for sending the events has yet to start. `started` indicates the webhook is active and sending events. `disabled` indicates the webhook has been disabled by a client and is not currently sending events. `error` indicates an error condition has been encountered and the webhook has been disabled by the service instance. More information about the error condition will be indicated by the service instance in the `error` parameter. Service implementations SHOULD implement appropriate retries and only enter the `error` state when absolutely necesary. A webhook in the `error` or `disabled` state may be re-enabled by a client by setting the status to `created`. A webhook in the `created` or `started` state may be disabled by a client by setting the status to `disabled`. Attempting to transition an `error` status to `disabled` SHOULD be rejected.",
    )


class Flowaudio(Flowcore):
    """
    Describes an audio Flow
    """

    format: Format = Field(
        ..., description="The primary content type URN for the Flow."
    )
    essence_parameters: EssenceParameters = Field(
        ...,
        description="Describes the parameters of the essence inside this audio Flow",
        title="Audio Flow Essence Parameters",
    )


class Flowsegment(Objectcore):
    """
    Provides the location and metadata of the media files corresponding to timerange segments of a Flow.
    """

    object_id: str = Field(
        ..., description="The object store identifier for the Media Object."
    )
    ts_offset: Optional[Timestamp] = Field(
        None,
        description="The timestamp offset between the sample timestamps stored in the media file and the corresponding timestamp in the Segment, ie. ts_offset = segment ts - media object ts. Assumed to be 0:0 if not set. Format as described by the [Timestamp](../schemas/timestamp#top) type",
    )
    timerange: Timerange = Field(
        ...,
        description="The timerange for the samples contained in the Segment. The timerange start is always inclusive. If samples have a duration then the timerange end is exclusive and covers at least the duration of the last sample. The exclusive timerange end will typically be set to the timestamp of the next sample. If the samples don't have a duration then the timerange end is inclusive. Format is described by the [TimeRange](../schemas/timerange#top) type. Note that where temporal re-ordering is used, the timerange and samples refers to the presentation timeline.",
    )
    last_duration: Optional[Timestamp] = Field(
        None,
        description="The difference between the exclusive end of the `timerange` and the last sample timestamp. Format as described by the [Timestamp](../schemas/timestamp#top) type, but cannot be negative",
    )
    sample_offset: Optional[int] = Field(
        None,
        description="The start of the Segment represented as a count of samples from the start of the Media Object. Note that a sample is a video frame or audio sample. A (coded) audio frame has multiple audio samples. Assumed to be 0 if not set.",
    )
    sample_count: Optional[int] = Field(
        None,
        description="The count of samples in the Segment (which may be fewer than in the Media Object). The count could be less than expected given the Segment duration and rate if there are gaps. If not set, every sample from sample_offset onwards is used. Note that a sample is a video frame or audio sample. A (coded) audio frame has multiple audio samples",
    )


class Object(Objectcore):
    id: str = Field(..., description="The Media Object identifier.")
    referenced_by_flows: List[Uuid] = Field(
        ...,
        description="List of Flows that reference this Media Object via Flow Segments in this store instance.",
    )
    first_referenced_by_flow: Optional[Uuid] = Field(
        None,
        description="The first Flow that had a Flow Segment reference the Media Object in this store instance. This Flow is also present in 'referenced_by_flows' if it is still referenced by the Flow. This property is optional and may in some implementations become unset if the Flow no longer references the media object, e.g. because it was deleted.",
    )


class Flow(RootModel[Union[Flowvideo, Flowaudio, Flowimage, Flowdata, Flowmulti]]):
    root: Union[Flowvideo, Flowaudio, Flowimage, Flowdata, Flowmulti] = Field(
        ..., description="Describes a Flow", title="Flow"
    )
