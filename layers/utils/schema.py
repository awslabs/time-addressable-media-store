# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-13T10:43:34+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    PositiveInt,
    RootModel,
    conint,
    constr,
)


class Uuid(
    RootModel[
        constr(
            pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
        )
    ]
):
    root: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(..., title="UUID")


class Contentformat(Enum):
    """
    Identifies the content format for a flow or source using a URN string.
    """

    urn_x_nmos_format_video = "urn:x-nmos:format:video"
    urn_x_tam_format_image = "urn:x-tam:format:image"
    urn_x_nmos_format_audio = "urn:x-nmos:format:audio"
    urn_x_nmos_format_data = "urn:x-nmos:format:data"
    urn_x_nmos_format_multi = "urn:x-nmos:format:multi"


class Mimetype(RootModel[constr(pattern=r".*/.*")]):
    root: constr(pattern=r".*/.*") = Field(
        ..., description="MIME Type string.", title="MIME Type"
    )


class Status(Enum):
    """
    Status of the delete request
    """

    created = "created"
    started = "started"
    done = "done"
    error = "error"


class GetUrl(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    label: Optional[str] = Field(
        None,
        description="Label identifying this URL. If the 'label' is not set then this URL can't be filtered for using the 'accept_get_urls' API query parameter.",
    )
    url: str = Field(
        ...,
        description="A URL to which a GET request can be made to directly retrieve the contents of the segment. Clients should include credentials if the provide URL is on the same origin as the API endpoint",
    )


class Flowstoragepost(BaseModel):
    """
    Post data for the flow storage endpoint
    """

    limit: Optional[int] = Field(
        None,
        description="Limit the number of storage segments in each response page. Implementations may specify their own default and maximum for the limit",
    )
    object_ids: Optional[List[str]] = Field(
        None,
        description="Array of object_ids to use. The supplied object_ids must be new and not already in use in this store. A 400 response will be returned if any supplied object_id already exists.",
    )


class Action(Enum):
    create_bucket = "create_bucket"


class Object(BaseModel):
    """
    Describes a media object in the store.
    """

    object_id: str = Field(..., description="The media object identifier.")
    referenced_by_flows: List[
        constr(
            pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
        )
    ] = Field(
        ...,
        description="List of Flows that reference this media object via Flow Segments in this store.",
    )
    first_referenced_by_flow: Optional[
        constr(
            pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
        )
    ] = Field(
        None,
        description="The first Flow that had a Flow Segment reference the media object in this store. This Flow is also present in 'referenced_by_flows' if it is still referenced by the Flow. This property is optional and may in some implementations become unset if the Flow no longer references the media object, e.g. because it was deleted.",
    )


class Servicepost(BaseModel):
    """
    Post update to the service info
    """

    name: Optional[str] = Field(None, description="The service instance name")
    description: Optional[str] = Field(
        None, description="The service instance description"
    )


class Type(Enum):
    """
    The type of the media store. This determines the endpoints for reading and writing media
    """

    http_object_store = "http_object_store"


class MediaStore(BaseModel):
    """
    Provide information about the media store for this service
    """

    type: Type = Field(
        ...,
        description="The type of the media store. This determines the endpoints for reading and writing media",
    )


class Format(Enum):
    """
    The primary content type URN for the Source.
    """

    urn_x_nmos_format_video = "urn:x-nmos:format:video"
    urn_x_tam_format_image = "urn:x-tam:format:image"
    urn_x_nmos_format_audio = "urn:x-nmos:format:audio"
    urn_x_nmos_format_data = "urn:x-nmos:format:data"
    urn_x_nmos_format_multi = "urn:x-nmos:format:multi"


class Tags(RootModel[Optional[Dict[str, str]]]):
    """
    Key value is a freeform string.
    """

    root: Optional[Dict[str, str]] = None


class Timerange(
    RootModel[
        constr(
            pattern=r"^(\[|\()?(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?(_(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?)?(\]|\))?$"
        )
    ]
):
    root: constr(
        pattern=r"^(\[|\()?(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?(_(-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8}))?)?(\]|\))?$"
    ) = Field(
        ...,
        description="A timerange of timestamps. It is represented using one or two timestamps with inclusivity and exclusivity markers.\n\nE.g.\n* `[0:0_10:0)` represents 10 seconds of media starting at timestamp `0:0` and ending before `10:0`.\n* `(5:0_` represents a timerange starting after `5:0` and to eternity.\n* `[1694429247:0_1694429248:0)` is a 1 second TAI timerange starting at 2023-09-11T10:46:50.0Z UTC.\n* `[1694429247:0]` is an instantaneous TAI timerange at 2023-09-11T10:46:50.0Z UTC.\n  This is equivalent to `[1694429247:0_1694429247:0]`.\n  The short syntax is preferred due to ease of identification as instantaneous.\n  Instantaneous TimeRanges cannot use exclusive markers (i.e. `(` or `)`).\n* A `[` or `]` indicates that bound is inclusive, and a `(` or `)` indicates that bound is exclusive.\n\nDetails of the format can be found in the [Timestamps in TAMS](https://github.com/bbc/tams/blob/main/docs/appnotes/0008-timestamps-in-TAMS.md) application note.\n",
        title="TimeRange",
    )


class Webhookpost(BaseModel):
    """
    Register to receive updates via webhook
    """

    url: str = Field(
        ...,
        description="The URL to which the API should make HTTP POST requests with event data",
    )
    api_key_name: Optional[str] = Field(
        None,
        description="The HTTP header name that is added to the event POST with value 'api_key_value'",
    )
    api_key_value: Optional[str] = Field(
        None, description="The value that the HTTP header 'api_key_name' will be set to"
    )
    events: List[str] = Field(..., description="List of event types to receive")
    flow_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow and Flow Segment events to Flows in the given list of Flow IDs",
    )
    source_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow, Flow Segment and Source events to Sources in the given list of Source IDs",
    )
    flow_collected_by_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow and Flow Segment events to those with Flow that is collected by a Flow Collection in the given list of Flow Collection IDs",
    )
    source_collected_by_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow, Flow Segment and Source events to those with Source that is collected by a Source Collection in the given list of Source Collection IDs",
    )
    accept_get_urls: Optional[List[str]] = Field(
        None,
        description="List of labels of URLs to include in the `get_urls` property in `flows/segments_added` events. This option is the same as the `accept_get_urls` query parameter for the /flows/{flowId}/segments API endpoint, except that the labels are represented using a JSON array rather than a (comma separated list) string.",
    )


class Webhook(BaseModel):
    """
    Register to receive updates via webhook
    """

    url: str = Field(
        ...,
        description="The URL to which the API should make HTTP POST requests with event data",
    )
    api_key_name: Optional[str] = Field(
        None, description="The HTTP header name that is added to the event POST"
    )
    api_key_value: Optional[str] = Field(
        None, description="The value that the HTTP header 'api_key_name' will be set to"
    )
    events: List[str] = Field(..., description="List of event types to receive")
    flow_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow and Flow Segment events to Flows in the given list of Flow IDs",
    )
    source_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow, Flow Segment and Source events to Sources in the given list of Source IDs",
    )
    flow_collected_by_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow and Flow Segment events to those with Flow that is collected by a Flow Collection in the given list of Flow Collection IDs",
    )
    source_collected_by_ids: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Limit Flow, Flow Segment and Source events to those with Source that is collected by a Source Collection in the given list of Source Collection IDs",
    )
    accept_get_urls: Optional[List[str]] = Field(
        None,
        description="List of labels of URLs to include in the `get_urls` property in `flows/segments_added` events. This option is the same as the `accept_get_urls` query parameter for the /flows/{flowId}/segments API endpoint, except that the labels are represented using a JSON array rather than a (comma separated list) string.",
    )


class Error(BaseModel):
    """
    Provides more information for the error status.
    """

    type: str = Field(..., description="The error type name.")
    summary: str = Field(
        ..., description="Summary description of the error and causes."
    )
    traceback: Optional[List[str]] = Field(
        None, description="Stack trace leading to error (as a list of strings)"
    )
    time: datetime = Field(
        ..., description="Time at which the error ocurred, to aid in log correlation"
    )


class Eventstreamcommon(BaseModel):
    """
    Describes an event stream mechanism available in this implementation of TAMS
    """

    name: str = Field(
        ...,
        description="Name of this type of event stream mechanism. Must be unique. Any name defined in this specification is reserved",
    )
    docs: Optional[str] = Field(
        None,
        description="Location (e.g. a URL) at which documentation for this event stream mechanism may be found",
    )
    config: Optional[Dict[str, Any]] = Field(
        None, description="Configuration options required to make use of this mechanism"
    )


class Format1(Enum):
    """
    The primary content type URN for the flow.
    """

    urn_x_nmos_format_audio = "urn:x-nmos:format:audio"


class CodecParameters(BaseModel):
    coded_frame_size: Optional[int] = Field(
        None, description="The fixed number of samples per coded audio frame."
    )
    mp4_oti: Optional[int] = Field(
        None,
        description="The MPEG-4 Object Type Identification. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#mpeg-4_audio",
    )


class UncType(Enum):
    """
    The uncompressed audio multi-channel representation type. If codec is `audio/x-raw-int` or `audio/x-raw-float`, unc_type must be set.
    """

    interleaved = "interleaved"
    planar = "planar"
    pairs = "pairs"


class UncParameters(BaseModel):
    unc_type: UncType = Field(
        ...,
        description="The uncompressed audio multi-channel representation type. If codec is `audio/x-raw-int` or `audio/x-raw-float`, unc_type must be set.",
    )


class EssenceParameters(BaseModel):
    """
    Describes the parameters of the essence inside this audio Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    sample_rate: PositiveInt = Field(
        ..., description="The fixed number of samples per second."
    )
    channels: PositiveInt = Field(..., description="The channel count.")
    bit_depth: Optional[PositiveInt] = Field(
        None,
        description="The number of significant bits used to represent the audio sample. The minumum number of bytes then equals `round_up(bit_depth / 8)`. If codec is `audio/x-raw-int` bit_depth must be set. If codec is `audio/x-raw-float` bit_depth must be set to 32 or 64",
    )
    codec_parameters: Optional[CodecParameters] = Field(
        None, title="Audio Codec Parameters"
    )
    unc_parameters: Optional[UncParameters] = Field(
        None, title="Uncompressed Audio Parameters"
    )


class Format2(Enum):
    """
    The primary content type URN for the flow.
    """

    urn_x_nmos_format_data = "urn:x-nmos:format:data"


class EssenceParameters1(BaseModel):
    """
    Describes the parameters of the essence inside this data Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    data_type: Optional[str] = Field(
        None,
        description="The type of information encoded in the flow, identified using a URN. e.g. The data_type may be urn:x-tams:data:bounding-box, and the codec `application/json`.",
    )


class Format3(Enum):
    """
    The primary content type URN for the flow.
    """

    urn_x_tam_format_image = "urn:x-tam:format:image"


class AspectRatio(BaseModel):
    """
    The display aspect ratio. i.e. display_width / display_height
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: PositiveInt = Field(..., description="denominator")


class EssenceParameters2(BaseModel):
    """
    Describes the parameters of the essence inside this image Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    frame_width: PositiveInt = Field(
        ..., description="The width of the picture in pixels."
    )
    frame_height: PositiveInt = Field(
        ..., description="The height of the picture in pixels."
    )
    aspect_ratio: Optional[AspectRatio] = Field(
        None,
        description="The display aspect ratio. i.e. display_width / display_height",
    )


class Format4(Enum):
    """
    The primary content type URN for the flow.
    """

    urn_x_nmos_format_multi = "urn:x-nmos:format:multi"


class Format5(Enum):
    """
    The primary content type URN for the flow.
    """

    urn_x_nmos_format_video = "urn:x-nmos:format:video"


class FrameRate(BaseModel):
    """
    The fixed number of frames per second. If this parameter is unset, the frame_rate is either unknown or variable.
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: Optional[PositiveInt] = Field(1, description="denominator")


class InterlaceMode(Enum):
    """
    Interlaced video mode for frames in this Flow
    """

    progressive = "progressive"
    interlaced_tff = "interlaced_tff"
    interlaced_bff = "interlaced_bff"
    interlaced_psf = "interlaced_psf"


class Colorspace(Enum):
    """
    Colorspace used for the video
    """

    BT601 = "BT601"
    BT709 = "BT709"
    BT2020 = "BT2020"
    BT2100 = "BT2100"


class TransferCharacteristic(Enum):
    """
    Transfer characteristic
    """

    SDR = "SDR"
    HLG = "HLG"
    PQ = "PQ"


class PixelAspectRatio(BaseModel):
    """
    The pixel aspect ratio. This is usually 1:1 (i.e. square pixels) for modern video. Some, usually older, video formats use non-square pixels e.g. some Standard Definition video. This is where that may be indicated.
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: PositiveInt = Field(..., description="denominator")


class ComponentType(Enum):
    """
    Picture component representation.
    """

    YCbCr = "YCbCr"
    RGB = "RGB"


class UncType1(Enum):
    """
    Uncompressed picture packing type. If codec is `video/raw`, unc_type must be set.
    """

    planar = "planar"
    YUYV = "YUYV"
    UYVY = "UYVY"
    AYUV = "AYUV"
    v210 = "v210"
    v216 = "v216"
    RGB = "RGB"
    RGBx = "RGBx"
    xRGB = "xRGB"
    BGRx = "BGRx"
    xBGR = "xBGR"
    RGBA = "RGBA"
    ARGB = "ARGB"
    BGRA = "BGRA"
    ABGR = "ABGR"
    alpha = "alpha"


class UncParameters1(BaseModel):
    unc_type: UncType1 = Field(
        ...,
        description="Uncompressed picture packing type. If codec is `video/raw`, unc_type must be set.",
    )


class AvcParameters(BaseModel):
    profile: int = Field(
        ...,
        description="AVC / H.264 profile byte. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#using_the_codecs_parameter",
    )
    level: int = Field(
        ...,
        description="AVC / H.264 level byte. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#using_the_codecs_parameter",
    )
    flags: int = Field(
        ...,
        description="AVC / H.264 flags byte. For more information on the use of this property in codec strings, see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#using_the_codecs_parameter",
    )


class EssenceParameters3(BaseModel):
    """
    Describes the parameters of the essence inside this video Flow
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    frame_rate: Optional[FrameRate] = Field(
        None,
        description="The fixed number of frames per second. If this parameter is unset, the frame_rate is either unknown or variable.",
    )
    frame_width: PositiveInt = Field(
        ..., description="The width of the picture in pixels."
    )
    frame_height: PositiveInt = Field(
        ..., description="The height of the picture in pixels."
    )
    bit_depth: Optional[PositiveInt] = Field(
        None,
        description="The number of significant bits used to represent the video component sample. If codec is `video/raw`, bit_depth must be set.",
    )
    interlace_mode: Optional[InterlaceMode] = Field(
        None, description="Interlaced video mode for frames in this Flow"
    )
    colorspace: Optional[Colorspace] = Field(
        None, description="Colorspace used for the video"
    )
    transfer_characteristic: Optional[TransferCharacteristic] = Field(
        None, description="Transfer characteristic"
    )
    aspect_ratio: Optional[AspectRatio] = Field(
        None,
        description="The display aspect ratio. i.e. display_width / display_height",
    )
    pixel_aspect_ratio: Optional[PixelAspectRatio] = Field(
        None,
        description="The pixel aspect ratio. This is usually 1:1 (i.e. square pixels) for modern video. Some, usually older, video formats use non-square pixels e.g. some Standard Definition video. This is where that may be indicated.",
    )
    component_type: Optional[ComponentType] = Field(
        None, description="Picture component representation."
    )
    horiz_chroma_subs: Optional[PositiveInt] = Field(
        None,
        description="Horizontal chroma component sub-sampling. When unc_type is set to a YUV type, horiz_chroma_subs must be set.",
    )
    vert_chroma_subs: Optional[PositiveInt] = Field(
        None,
        description="Vertical chroma component sub-sampling. When unc_type is set to a YUV type, vert_chroma_subs must be set.",
    )
    unc_parameters: Optional[UncParameters1] = Field(
        None, title="Uncompressed Video Parameters"
    )
    avc_parameters: Optional[AvcParameters] = Field(None, title="AVC Codec Parameters")


class Httprequest(BaseModel):
    """
    Gives information on a particular http request a client should perform
    """

    model_config = ConfigDict(
        extra="allow",
    )
    url: str = Field(..., description="The URL to make the request to")
    body: Optional[str] = Field(
        None,
        description="The text of the body which needs to be included in the request",
    )
    content_type: Optional[str] = Field(
        None, alias="content-type", description="The content type which must be used"
    )
    headers: Optional[Dict[str, str]] = Field(
        None, description="Additional headers that should be included"
    )


class Timestamp(RootModel[constr(pattern=r"^-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8})$")]):
    root: constr(pattern=r"^-?(0|[1-9][0-9]*):(0|[1-9][0-9]{0,8})$") = Field(
        ...,
        description='A signed nanosecond resolution timestamp represented as "{sign?}{seconds}:{nanoseconds}". The intended\ninterpretation of the value is assumed to be defined elsewhere.\n\nE.g.\n* "1:40000000" is the timestamp of the 27th video frame for 25 Hz video with origin at "0:0".\n* "1694429247:40000000" is the TAI timestamp for a video frame at 2023-09-11T10:46:50.04Z UTC.\n\nDetails of the format can be found in the [Timestamps in TAMS](https://github.com/bbc/tams/blob/main/docs/appnotes/0008-timestamps-in-TAMS.md) application note.\n',
        title="Timestamp",
    )


class ChannelNumber(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class AudioTrack(BaseModel):
    """
    Mapping for channels in audio tracks to the Flow channels
    """

    channel_numbers: Optional[List[ChannelNumber]] = Field(
        None,
        description="Array of (zero-based) container channel numbers in Flow order",
        min_length=1,
    )
    channel_range: Optional[constr(pattern=r"^[0-9]+_[0-9]+$")] = Field(
        None, description="Inclusive range of (zero-based) container channel numbers"
    )


class Mp2tsContainer(BaseModel):
    """
    Mapping to MPEG-2 Transport Stream containers, ISO/IEC 13818-1 or ITU-T Recommendation H.222.0
    """

    pid: Optional[int] = Field(
        None, description="The packet ID for the elementary stream packets"
    )


class MxfContainer(BaseModel):
    """
    Mapping to Material Exchange Format containers, SMPTE ST 377-1
    """

    package_uid: Optional[
        constr(
            pattern=r"^urn:smpte:umid:[0-9a-fA-F]{8}(.[0-9a-fA-F]{8}){7}$|^urn:uuid:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
        )
    ] = Field(None, description="The package UID. Either a SMPTE UMID URN or UUID URN")
    track_id: Optional[int] = Field(None, description="The track ID in the package")


class IsobmffContainer(BaseModel):
    """
    Mapping to ISO Base Media File Format (e.g. MP4 and MOV) containers, ISO/IEC 14496-12
    """

    track_id: Optional[int] = Field(None, description="The track ID")


class Containermapping(BaseModel):
    """
    Defines the location of Flow essence data in a container track
    """

    track_index: Optional[conint(ge=0)] = Field(
        None,
        description="A zero-based and sequential track index in the container. This assumes a reliable ordering of tracks",
    )
    format_track_index: Optional[conint(ge=0)] = Field(
        None,
        description="A zero-based and sequential track index in the container for a particular Flow format. A container with a video and 2 audio tracks would have a format_track_index 0 for the video Flow and format_track_index 0 and 1 for the audio Flows. This assumes a reliable ordering of tracks for each Flow format",
    )
    audio_track: Optional[AudioTrack] = Field(
        None, description="Mapping for channels in audio tracks to the Flow channels"
    )
    mp2ts_container: Optional[Mp2tsContainer] = Field(
        None,
        description="Mapping to MPEG-2 Transport Stream containers, ISO/IEC 13818-1 or ITU-T Recommendation H.222.0",
    )
    mxf_container: Optional[MxfContainer] = Field(
        None,
        description="Mapping to Material Exchange Format containers, SMPTE ST 377-1",
    )
    isobmff_container: Optional[IsobmffContainer] = Field(
        None,
        description="Mapping to ISO Base Media File Format (e.g. MP4 and MOV) containers, ISO/IEC 14496-12",
    )


class SegmentDuration(BaseModel):
    """
    The target flow segment duration in seconds. The duration for each segment may vary around this target value. See also the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote for how this property can be used to calculate buffer sizes.
    """

    numerator: PositiveInt = Field(..., description="numerator")
    denominator: Optional[PositiveInt] = Field(1, description="denominator")


class Deletionrequest(BaseModel):
    """
    Describes an ongoing deletion request
    """

    id: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(..., description="Deletion Request ID")
    flow_id: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(..., description="ID of the flow to which the deletion request relates")
    timerange_to_delete: Timerange = Field(
        ...,
        description="The timerange of FlowSegments to be deleted in this request, as described by the [TimeRange](../schemas/timerange#top) type",
    )
    timerange_remaining: Optional[Timerange] = Field(
        None,
        description="The timerange of FlowSegments not yet deleted by this request, as described by the [TimeRange](../schemas/timerange#top) type",
    )
    delete_flow: bool = Field(
        ...,
        description="Whether the Flow should be deleted once the timerange has been",
    )
    created: Optional[datetime] = Field(
        None, description="Date/Time when this deletion request was created"
    )
    created_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that created the deletion request. Implementations SHOULD set suitable default values for `created_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    updated: Optional[datetime] = Field(
        None, description="Date/Time when this deletion request was updated"
    )
    expiry: Optional[datetime] = Field(
        None, description="Date/Time when this deletion request will be deleted"
    )
    status: Status = Field(..., description="Status of the delete request")
    error: Optional[Error] = Field(
        None,
        description="Provides more information for the error status, as described by the [Error](../schemas/error#top) type",
    )


class Deletionrequestslist(RootModel[List[Deletionrequest]]):
    root: List[Deletionrequest] = Field(..., title="Deletion Requests List")


class FailedSegment(BaseModel):
    """
    Failed segment details
    """

    object_id: str = Field(
        ...,
        description="The object ID of the segment which has failed to register with the TAMS API",
    )
    timerange: Optional[Timerange] = Field(
        None,
        description="The timerange of segment that has failed, as described by the [TimeRange](../schemas/timerange#top) type",
    )
    error: Optional[Error] = Field(
        None,
        description="Provides more information for the error status, as described by the [Error](../schemas/error#top) type",
    )


class Flowsegmentbulkfailure(BaseModel):
    """
    List of segments that have failed to register
    """

    failed_segments: List[FailedSegment] = Field(
        ...,
        description="The list of segments which have failed to register with the TAMS API",
    )


class Flowsegment(BaseModel):
    """
    Provides the location and metadata of the media files corresponding to timerange segments of a Flow.
    """

    object_id: str = Field(
        ..., description="The object store identifier for the media object."
    )
    ts_offset: Optional[Timestamp] = Field(
        None,
        description="The timestamp offset between the sample timestamps stored in the media file and the corresponding timestamp in the segment, ie. ts_offset = segment ts - media object ts. Assumed to be 0:0 if not set. Format as described by the [Timestamp](../schemas/timestamp#top) type, but cannot be negative",
    )
    timerange: Timerange = Field(
        ...,
        description="The timerange for the samples contained in the segment. The timerange start is always inclusive. If samples have a duration then the timerange end is exclusive and covers at least the duration of the last sample. The exclusive timerange end will typically be set to the timestamp of the next sample. If the samples don't have a duration then the timerange end is inclusive. Format is described by the [TimeRange](../schemas/timerange#top) type. Note that where temporal re-ordering is used, the timerange and samples refers to the presentation timeline.",
    )
    last_duration: Optional[Timestamp] = Field(
        None,
        description="The difference between the exclusive end of the `timerange` and the last sample timestamp. Format as described by the [Timestamp](../schemas/timestamp#top) type, but cannot be negative",
    )
    sample_offset: Optional[int] = Field(
        None,
        description="The start of the segment represented as a count of samples from the start of the object. Note that a sample is a video frame or audio sample. A (coded) audio frame has multiple audio samples. Assumed to be 0 if not set.",
    )
    sample_count: Optional[int] = Field(
        None,
        description="The count of samples in the segment (which may be fewer than in the object). The count could be less than expected given the segment duration and rate if there are gaps. If not set, every sample from sample_offset onwards is used. Note that a sample is a video frame or audio sample. A (coded) audio frame has multiple audio samples",
    )
    get_urls: Optional[List[GetUrl]] = Field(
        None,
        description="A list of URLs to which a GET request can be made to directly retrieve the contents of the segment. This is required by the `http_object_store` media store type, which is the only one currently described. Clients may choose any URL in the list and treat them as identical, however servers may sort the list such that the preferred URL is first.",
    )
    key_frame_count: Optional[int] = Field(
        None,
        description="The number of key frames in the segment. This should be set greater than zero when the segment contains key frames that serve as a stream access point",
    )


class PreItem(BaseModel):
    """
    An action
    """

    action: Action
    bucket_id: Optional[str] = Field(
        None, description="The name of the bucket that needs to be created"
    )
    put_url: Optional[Httprequest] = None
    put_cors_url: Optional[Httprequest] = None


class MediaObject(BaseModel):
    """
    Information for a media object
    """

    object_id: str = Field(
        ..., description="The object store identifier for the media object."
    )
    put_url: Httprequest
    put_cors_url: Optional[Httprequest] = None


class Flowstorage(BaseModel):
    """
    Gives information on storage for media objects. This schema is for the `http_object_store` media store type which provides URLs for storing media objects in bucket, and is the only store type currently implemented.
    """

    model_config = ConfigDict(
        extra="forbid",
    )
    pre: Optional[List[PreItem]] = Field(
        None,
        description="Actions that need to be taken before the media object can be written",
    )
    media_objects: Optional[List[MediaObject]] = Field(
        None,
        description="List of information for identifying and uploading media objects",
    )


class Service(BaseModel):
    """
    Provides information about the store service
    """

    name: Optional[str] = Field(None, description="The service instance name")
    description: Optional[str] = Field(
        None, description="The service instance description"
    )
    type: str = Field(
        ...,
        description="The type identifier for the service. The value must start with 'urn:x-tams:service'",
    )
    api_version: constr(pattern=r"^(0|[1-9]\d*)\.(0|[1-9]\d*)$") = Field(
        ...,
        description="The version of the TAMS API specification this deployment implements",
    )
    service_version: Optional[str] = Field(
        None,
        description="The version of software providing this service. Note: Different implementations and software houses may use different conventions for their version identification. As such, this field is intentionally permissive and intended to be informative only. Implementations should avoid using this field to determine compatibility.",
    )
    media_store: MediaStore = Field(
        ..., description="Provide information about the media store for this service"
    )
    event_stream_mechanisms: Optional[List[Eventstreamcommon]] = Field(
        None,
        description="List the types of event stream that this implementation supports",
    )


class Collectionitem(BaseModel):
    """
    Describes how an object (Source or Flow) is collected into another object of the same type
    """

    id: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(
        ...,
        description="Source or Flow Identifier of the member of this collection. Sources must only collect Sources, and Flows must only collect Flows. Must already be registered in TAMS",
    )
    role: str = Field(
        ...,
        description="A human-readable role of the element in this collection (e.g. 'R' to denote a right audio channel in a collection of mono audio Sources)",
    )
    container_mapping: Optional[Containermapping] = Field(
        None,
        description="Describes the mapping of the Flow essence from this Flow collection's container",
    )


class Flowcollection(RootModel[List[Collectionitem]]):
    root: List[Collectionitem] = Field(..., title="Flow Collection")


class Source(BaseModel):
    """
    Describes a Source: an abstract representation of a piece of media as defined in <https://specs.amwa.tv/ms-04/releases/v1.0.0/docs/2.2._Explanation_-_Source.html>

    Sources may be elemental (and represented directly by a Flow), or may represent a collection of other Sources, e.g. a Source collecting video and audio together.
    """

    id: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(..., description="Source identifier")
    format: Format = Field(
        ..., description="The primary content type URN for the Source."
    )
    label: Optional[str] = Field(
        None, description="Freeform string label for the Source"
    )
    description: Optional[str] = Field(
        None, description="Freeform text describing the Source"
    )
    created_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that created the Source. Implementations SHOULD set suitable default values for `created_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    updated_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that updated the Source metadata most recently. Implementations SHOULD set suitable default values for `updated_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    created: Optional[datetime] = Field(
        None,
        description="The date-time the Source was created in a given context, e.g. in the store. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    updated: Optional[datetime] = Field(
        None,
        description="The date-time the Source metadata was last updated in a given context, e.g. in the store. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    tags: Optional[Tags] = None
    source_collection: Optional[List[Collectionitem]] = Field(
        None,
        description="List of Sources that are collected together by this Source. This attribute is intended to be read-only. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally. Source collections can be inferred from Flow collection definitions.",
    )
    collected_by: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Sources that reference this Source to include it in a collection. This attribute is intended to be read-only. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally. Source collections can be inferred from Flow collection definitions.",
    )


class Flowcore(BaseModel):
    """
    Describes a Flow (common properties to all Flows, imported by type-specific specifications)
    """

    id: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(..., description="Flow identifier")
    source_id: constr(
        pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
    ) = Field(..., description="Source identifier")
    label: Optional[str] = Field(None, description="Freeform string label for the flow")
    description: Optional[str] = Field(
        None, description="Freeform text describing the flow"
    )
    created_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that created the flow. Implementations SHOULD set suitable default values for `created_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    updated_by: Optional[str] = Field(
        None,
        description="A string identifier for the entity that updated the flow metadata most recently. Implementations SHOULD set suitable default values for `updated_by` based on the principal accessing the system, and MAY permit clients to edit the value, subject to suitable permissions-based limitations.",
    )
    tags: Optional[Tags] = None
    metadata_version: Optional[str] = Field(
        None,
        description="A change to the flow metadata, not including metadata_version, last_update or segments, results in a new version. If the metadata_version for flow instances is identical then the metadata is identical.",
    )
    generation: Optional[conint(ge=0)] = Field(
        None,
        description="An indication of how many lossy encodings the flow content has been through. A flow with a higher generation may contain less of the original information than a flow with a lower generation.",
    )
    created: Optional[datetime] = Field(
        None,
        description="The date-time the flow was created in a given context, e.g. in the store. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    metadata_updated: Optional[datetime] = Field(
        None,
        description="The date-time the flow metadata was updated in a given context, e.g. in the store. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    segments_updated: Optional[datetime] = Field(
        None,
        description="The date-time the flow segments were updated in a given context, e.g. in the store. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    read_only: Optional[bool] = Field(
        None,
        description="If set to 'true', implementations SHOULD reject client requests to update Flow metadata (other than the read_only property), Flow Segments and media objects",
    )
    codec: Optional[constr(pattern=r"^[^\s/]+/[^\s/]+$")] = Field(
        None,
        description="A MIME type identification of the (lossy or lossless) coding used for the flow content.",
    )
    container: Optional[constr(pattern=r"^[^\s/]+/[^\s/]+$")] = Field(
        None, description="The container MIME type for flow segments."
    )
    avg_bit_rate: Optional[conint(ge=0)] = Field(
        None,
        description="The average bit rate of the flow segments in 1000 bits/second. A precise definition can be found in the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote.",
    )
    max_bit_rate: Optional[conint(ge=0)] = Field(
        None,
        description="The maximum bit rate of the flow segments in 1000 bits/second. A precise definition can be found in the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote.",
    )
    segment_duration: Optional[SegmentDuration] = Field(
        None,
        description="The target flow segment duration in seconds. The duration for each segment may vary around this target value. See also the [Setting Flow Bit Rate Properties](https://github.com/bbc/tams/blob/main/docs/appnotes/0013-setting-flow-bit-rate-properties.md) AppNote for how this property can be used to calculate buffer sizes.",
    )
    timerange: Optional[Timerange] = Field(
        None,
        description="The timerange of samples available in the flow, as described by the [TimeRange](../schemas/timerange#top) type",
    )
    flow_collection: Optional[Flowcollection] = Field(
        None, description="List of Flows that are collected together by this Flow."
    )
    collected_by: Optional[
        List[
            constr(
                pattern=r"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"
            )
        ]
    ] = Field(
        None,
        description="Flows that reference this Flow to include it in a collection. This attribute is intended to be read-only. Implementations SHOULD ignore this if given in a PUT request, and instead manage it internally",
    )
    container_mapping: Optional[Containermapping] = Field(
        None,
        description="Describes the mapping of the Flow essence from the this Flow's container",
    )


class Flowaudio(Flowcore):
    """
    Describes an audio Flow
    """

    format: Format1 = Field(
        ..., description="The primary content type URN for the flow."
    )
    essence_parameters: EssenceParameters = Field(
        ...,
        description="Describes the parameters of the essence inside this audio Flow",
        title="Audio Flow Essence Parameters",
    )


class Flowdata(Flowcore):
    """
    Describes a data Flow
    """

    format: Format2 = Field(
        ..., description="The primary content type URN for the flow."
    )
    essence_parameters: EssenceParameters1 = Field(
        ...,
        description="Describes the parameters of the essence inside this data Flow",
        title="Data Flow Essence Parameters",
    )


class Flowimage(Flowcore):
    """
    Describes an still image Flow
    """

    format: Format3 = Field(
        ..., description="The primary content type URN for the flow."
    )
    essence_parameters: EssenceParameters2 = Field(
        ...,
        description="Describes the parameters of the essence inside this image Flow",
        title="Image Flow Essence Parameters",
    )


class Flowmulti(Flowcore):
    """
    Describes a multi-essence Flow
    """

    format: Format4 = Field(
        ..., description="The primary content type URN for the flow."
    )


class Flowvideo(Flowcore):
    """
    Describes a video Flow
    """

    format: Format5 = Field(
        ..., description="The primary content type URN for the flow."
    )
    essence_parameters: EssenceParameters3 = Field(
        ...,
        description="Describes the parameters of the essence inside this video Flow",
        title="Video Flow Essence Parameters",
    )


class Flow(RootModel[Union[Flowvideo, Flowaudio, Flowimage, Flowdata, Flowmulti]]):
    root: Union[Flowvideo, Flowaudio, Flowimage, Flowdata, Flowmulti] = Field(
        ..., description="Describes a Flow", title="Flow"
    )
